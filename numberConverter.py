# numberConverter.py

# Αυτό το αρχείο υλοποιεί μια εφαρμογή μετατροπής αριθμών μεταξύ διαφορετικών βάσεων (2, 8, 10, 16).
# Παρέχει γραφικό περιβάλλον χρήστη (GUI) με δυνατότητες όπως:
# - Επιλογή βάσεων εισόδου και εξόδου.
# - Ανταλλαγή βάσεων με το πάτημα ενός κουμπιού.
# - Εμφάνιση επιτρεπτών ψηφίων για κάθε βάση.
# - Μετατροπή ακέραιων και δεκαδικών αριθμών με ακρίβεια.
# - Αντιγραφή αποτελέσματος στο πρόχειρο.
# Χρησιμοποιεί τη βιβλιοθήκη customtkinter για μοντέρνο σχεδιασμό και υποστήριξη themes.


#==================== ΕΙΣΑΓΩΓΕΣ & ΘΕΜΑ ====================
from fractions import Fraction  # Για ακριβή υπολογισμό δεκαδικών αριθμών
"""Εισάγει την κλάση Fraction από το module fractions. 
Αυτή η κλάση επιτρέπει την αναπαράσταση ρητών αριθμών ως κλάσματα, 
αποφεύγοντας τα προβλήματα ακρίβειας των δεκαδικών (floating-point) αριθμών, 
ειδικά κατά τις επαναλαμβανόμενες πράξεις."""

import customtkinter as ctk
"""Εισάγει τη βιβλιοθήκη customtkinter, 
η οποία είναι ένα σύγχρονο toolkit GUI βασισμένο στο tkinter. 
Συμβατικά εισάγεται ως ctk."""

import tkinter as tk    # Για βασικές λειτουργίες GUI
"""Εισάγει την βασική βιβλιοθήκη tkinter. 
Παρόλο που χρησιμοποιείται το customtkinter, το tkinter εξακολουθεί να χρειάζεται 
για ορισμένες βασικές λειτουργίες ή σταθερές, όπως το tk.END για λειτουργίες σε widgets κειμένου."""

from themeManager import DARK_THEME # Εισαγωγή του σκούρου θέματος από το themeManager
"""Εισάγει ένα προσαρμοσμένο θέμα (DARK_THEME) από το αρχείο themeManager.py. 
Είναι πρακτική διαχωρισμού ανησυχιών (separation of concerns), 
όπου οι ρυθμίσεις θέματος βρίσκονται σε ένα ξεχωριστό module."""


#==================== ΚΛΑΣΗ NumberBaseConverter ====================
"""Ορίζεται η κλάση NumberBaseConverter η οποία κληρονομεί από το ctk.CTkFrame. 
        Αυτό σημαίνει ότι κάθε instance αυτής της κλάσης είναι ένα widget τύπου frame 
        στο οποίο θα τοποθετηθούν όλα τα υπόλοιπα στοιχεία της διεπαφής (κουμπιά, πεδία εισόδου/εξόδου κ.λπ.)
        και που μπορεί να ενσωματωθεί σε άλλα customtkinter containers. 
        Η κληρονομικότητα επιτρέπει στην κλάση να επωφελείται από τις ενσωματωμένες λειτουργίες ενός frame, 
        ενώ ταυτόχρονα προσθέτει την εξειδικευμένη λογική για τη μετατροπή αριθμών."""
class NumberBaseConverter(ctk.CTkFrame):                # Κλάση για τη μετατροπή βάσεων αριθμών

    def __init__(self, master, theme, **kwargs):        # Αρχικοποιεί το frame με το γονέα και το θέμα
        super().__init__(master, fg_color=theme.get("background", "#222222"), corner_radius=0)  # Κλήση του γονικού CTkFrame με το κατάλληλο χρώμα φόντου και ακτίνα γωνιών
        self.theme = theme                              # Αποθήκευση του θέματος για μελλοντική χρήση
        """
        Αυτός είναι ο constructor (__init__ μέθοδος) της κλάσης NumberBaseConverter. 
        o	self: Αναφέρεται στην ίδια την περίπτωση της κλάσης.
        o   master: Είναι το γονικό widget (π.χ., το κύριο παράθυρο της εφαρμογής) στο οποίο θα τοποθετηθεί αυτό το frame.
        o	theme: Ένα λεξικό που περιέχει τις ρυθμίσεις χρωμάτων και γραμματοσειρών για το θέμα της εφαρμογής.
        o	**kwargs: Επιτρέπει την αποδοχή οποιωνδήποτε επιπλέον ονομαστικών ορισμάτων (π.χ., width, height) 
            που μπορεί να περαστούν κατά την δημιουργία του αντικειμένου και τα οποία στη συνέχεια προωθούνται στον constructor της γονικής κλάσης.
        o	super().__init__(master, fg_color=..., corner_radius=0): Καλέι τον constructor της γονικής κλάσης (ctk.CTkFrame). 
            	master: Περιέχει το γονικό widget.
            	fg_color=theme.get("background", "#222222"): Ορίζει το χρώμα φόντου του frame, 
            παίρνοντας την τιμή "background" από το λεξικό theme. Αν δεν βρεθεί, χρησιμοποιεί το default #222222. 
            Η χρήση του theme.get() με default τιμή είναι μια robust πρακτική για την αποφυγή KeyError.
            	corner_radius=0: Ορίζει την ακτίνα των γωνιών του frame σε 0, κάνοντάς το τετράγωνο.
        o	self.theme = theme: Αποθηκεύει το λεξικό theme ως ένα χαρακτηριστικό της κλάσης (self.theme), 
            ώστε να είναι προσβάσιμο από άλλες μεθόδους της κλάσης για να ρυθμίζουν τα χρώματα άλλων widgets.
        """

        #==================== ΔΙΑΜΟΡΦΩΣΗ GRID ====================
        self.grid_columnconfigure((0, 4), weight=0, minsize=60)     # Ρύθμιση των στηλών 0 και 4 με βάρος 0 και ελάχιστο μέγεθος 60
        self.grid_columnconfigure((1, 2, 3), weight=1)              # Ρύθμιση των στηλών 1, 2 και 3 με βάρος 1 για επέκταση
        self.grid_rowconfigure(list(range(10)), weight=1)           # Ρύθμιση όλων των γραμμών με βάρος 1 για επέκταση
        """
        Αυτές οι γραμμές ρυθμίζουν τη διάταξη (layout) των widgets μέσα στο frame 
        χρησιμοποιώντας το grid layout manager του tkinter/customtkinter. 
        o	self.grid_columnconfigure(...): Καθορίζει πώς θα συμπεριφέρονται οι στήλες του grid 
            όταν αλλάζει το μέγεθος του παραθύρου. 
            	(0, 4), weight=0, minsize=60: Οι στήλες 0 και 4 έχουν βάρος 0, 
                που σημαίνει ότι δεν θα επεκτείνονται όταν το παράθυρο μεγαλώνει. 
                Θα έχουν ένα ελάχιστο μέγεθος 60 pixels. 
                Αυτές οι στήλες λειτουργούν ως "περιθώρια" ή σταθερά διαχωριστικά.
            	(1, 2, 3), weight=1: Οι στήλες 1,2, και 3 έχουν βάρος 1, 
                που σημαίνει ότι θα μοιράζονται ισομερώς τυχόν επιπλέον χώρο όταν το παράθυρο επεκτείνεται.
        o	self.grid_rowconfigure(list(range(10)), weight=1): Ρυθμίζει όλες τις γραμμές από 0 έως 9 
            (συνολικά 10 γραμμές) ώστε να έχουν βάρος 1. 
            Αυτό σημαίνει ότι όλες οι γραμμές θα επεκτείνονται ισομερώς όταν το παράθυρο μεγαλώνει κάθετα.
        """

        #==================== ΤΙΤΛΟΣ ====================
        self.title_label = ctk.CTkLabel(self, text="NUMBER BASE CONVERTER",                     # Ετικέτα τίτλου
                                        font=("Arial", 18, "bold"),                             # Γραμματοσειρά και μέγεθος
                                        text_color=theme.get("display_text", "#00ff00"))      # Χρώμα κειμένου τίτλου
        self.title_label.grid(row=0, column=0, columnspan=5, padx=20, pady=(20, 40))            # Τοποθέτηση της ετικέτας στη γραμμή 0, στήλες 0-4, με περιθώρια

        #==================== ΕΠΙΛΟΓΗ ΒΑΣΕΩΝ ====================
        self.from_label = ctk.CTkLabel(self, text="FROM BASE", font=("Arial", 14),          # Ετικέτα για τη βάση εισόδου
                                       text_color=theme.get("label_text", "#ffffff"))     # Χρώμα κειμένου ετικέτας
        self.from_label.grid(row=1, column=0, columnspan=2, padx=(20, 5), sticky="e")       # Τοποθέτηση της ετικέτας στη γραμμή 1, στήλες 0-1, με περιθώρια και στοίχιση στα δεξιά

        # Ετικέτα για τη βάση εξόδου
        self.to_label = ctk.CTkLabel(self, text="TO BASE", font=("Arial", 14),
                         text_color=theme.get("label_text", "#ffffff"))                 # Χρώμα κειμένου ετικέτας
        self.to_label.grid(row=1, column=3, columnspan=2, padx=(5, 20), sticky="w")     # Τοποθέτηση στη γραμμή 1, στήλες 3-4

        bases = ["2", "8", "10", "16"]  # Λίστα με τις διαθέσιμες βάσεις

        # Μενού επιλογής βάσης εισόδου
        self.from_base_menu = ctk.CTkComboBox(self, values=bases, border_width=2,
                              command=lambda _: self.update_allowed_digits_label(),         # Ενημέρωση επιτρεπτών ψηφίων όταν αλλάζει η βάση
                              button_color=theme.get("menu_button_bg", "#eb7c16"),          # Χρώμα κουμπιού
                              dropdown_fg_color=theme.get("dropdown_fg", "#4f4f4f"),        # Χρώμα φόντου dropdown
                              dropdown_text_color=theme.get("menu_text_color", "#ffffff"),  # Χρώμα κειμένου dropdown
                              text_color=theme.get("menu_text_color", "#ffffff"),           # Χρώμα κειμένου
                              border_color=theme.get("menu_button_bg", "#eb7c16"))          # Χρώμα περιγράμματος
        self.from_base_menu.set("10")  # Προεπιλεγμένη τιμή: 10
        self.from_base_menu.grid(row=2, column=0, columnspan=2, padx=(30, 5), pady=(0, 2), sticky="ew")  # Τοποθέτηση στη γραμμή 2, στήλες 0-1
        """
        •	self.from_base_menu = ctk.CTkComboBox(...): Αυτό το widget είναι ένα αναπτυσσόμενο μενού 
        για την επιλογή της βάσης εισόδου. 
        °	command=lambda _: self.update_allowed_digits_label(): Συνδέει την αλλαγή επιλογής στο αναπτυσσόμενο μενού 
            με την κλήση της μεθόδου self.update_allowed_digits_label(). 
            Το lambda _: είναι ένας τρόπος να δημιουργηθεί μια μικρή ανώνυμη συνάρτηση 
            που αγνοεί το όρισμα που συνήθως περνάει ένα command (στην περίπτωση του CTkComboBox είναι η νέα τιμή).
        """

        # Κουμπί για ανταλλαγή βάσεων
        self.swap_button = ctk.CTkButton(self, text="↔", font=("Arial", 16), width=40,
                         command=self.swap_bases,                                           # Συνάρτηση ανταλλαγής βάσεων
                         fg_color=theme.get("special_button_fg", "#eb7c16"))              # Χρώμα κουμπιού
        self.swap_button.grid(row=2, column=2, padx=(15, 15), pady=(0, 2), sticky="ew")     # Τοποθέτηση στη γραμμή 2, στήλη 2

        # Μενού επιλογής βάσης εξόδου
        self.to_base_menu = ctk.CTkComboBox(self, values=bases, border_width=2,
                            button_color=theme.get("menu_button_bg", "#eb7c16"),            # Χρώμα κουμπιού
                            dropdown_fg_color=theme.get("dropdown_fg", "#4f4f4f"),          # Χρώμα φόντου dropdown
                            dropdown_text_color=theme.get("menu_text_color", "#ffffff"),    # Χρώμα κειμένου dropdown
                            text_color=theme.get("menu_text_color", "#ffffff"),             # Χρώμα κειμένου
                            border_color=theme.get("menu_button_bg", "#eb7c16"))            # Χρώμα περιγράμματος
        self.to_base_menu.set("2")  # Προεπιλεγμένη τιμή: 2
        self.to_base_menu.grid(row=2, column=3, columnspan=2, padx=(5, 30), pady=(0, 2), sticky="ew")  # Τοποθέτηση στη γραμμή 2, στήλες 3-4

        #==================== ΕΠΙΤΡΕΠΤΑ ΨΗΦΙΑ ====================
        # Ετικέτα για εμφάνιση επιτρεπτών χαρακτήρων για τη βάση εισόδου
        self.allowed_digits_label = ctk.CTkLabel(self, text="", font=("Arial", 11, "italic"),   # Γραμματοσειρά και μέγεθος
                             text_color=self.theme.get("placeholder_text", "#aaaaaa"))          # Χρώμα κειμένου
        self.allowed_digits_label.grid(row=3, column=1, columnspan=3, pady=(0, 10))             # Τοποθέτηση στη γραμμή 3, στήλες 1-3
        self.update_allowed_digits_label()                                                      # Αρχική ενημέρωση επιτρεπτών ψηφίων
        """Αυτή η μέθοδος ενημερώνει μια ετικέτα στο GUI με τους επιτρεπτούς χαρακτήρες για την επιλεγμένη βάση εισόδου. 
        Παίρνει την τιμή από το from_base_menu, τη μετατρέπει σε ακέραιο και χρησιμοποιεί string slicing 
        για να επιλέξει τα αντίστοιχα ψηφία από την αλφαριθμητική ακολουθία "0123456789ABCDEF"."""

        #==================== ΠΕΔΙΟ ΕΙΣΟΔΟΥ ====================
        # Ετικέτα για το πεδίο εισαγωγής αριθμού
        self.input_label = ctk.CTkLabel(self, text="NUMBER", font=("Arial", 16, "bold"),        # Γραμματοσειρά και μέγεθος
                        text_color=theme.get("label_text", "#ffffff"))                        # Χρώμα κειμένου
        self.input_label.grid(row=4, column=1, columnspan=3, pady=(10, 2), sticky="s")          # Τοποθέτηση στη γραμμή 4, στήλες 1-3

        self.input_entry = ctk.CTkEntry(
            self,                                           # Το τρέχον frame ως γονέας
            fg_color=theme.get("entry_fg", "#ffffff"),     # Χρώμα φόντου του πεδίου
            text_color=theme.get("text_input", "#000000"), # Χρώμα κειμένου εισόδου
            font=("Arial", 20, "bold"),                    # Γραμματοσειρά και μέγεθος
            height=40,                                     # Ύψος πεδίου
            justify="center",                              # Στοίχιση κειμένου στο κέντρο
            placeholder_text="e.g. 12.75",                 # Κείμενο υπόδειξης (placeholder)
            placeholder_text_color=self.theme.get("placeholder_text", "#BEBEBE") # Χρώμα placeholder
        )
        self.input_entry.grid(row=5, column=1, columnspan=3, padx=10, pady=(0, 0), sticky="ew")     # Τοποθέτηση του πεδίου στη γραμμή 5, στήλες 1-3, με περιθώρια
        self.input_entry.bind("<Return>", lambda event: self.convert_number())             # Σύνδεση του πλήκτρου Enter ώστε να καλεί τη convert_number
        """
        •	self.input_entry = ctk.CTkEntry(...): Το πεδίο εισόδου του αριθμού. 
            o	self.input_entry.bind("<Return>", lambda event: self.convert_number()): 
            Αυτή η γραμμή συνδέει το πάτημα του πλήκτρου Enter (αναπαριστάται ως <Return>) 
            στο πεδίο εισόδου με την κλήση της μεθόδου self.convert_number(). 
            Το lambda event: χρησιμοποιείται επειδή το bind περνά ένα αντικείμενο event στη συνάρτηση callback.
        """

        #==================== ΜΗΝΥΜΑΤΑ ΒΟΗΘΕΙΑΣ/ΣΦΑΛΜΑΤΩΝ ====================
        # Ετικέτα για εμφάνιση μηνυμάτων βοήθειας ή σφαλμάτων
        self.tooltip_label = ctk.CTkLabel(
            self,                                             # Το τρέχον frame ως γονέας
            text="",                                          # Αρχικά κενό κείμενο
            font=("Arial", 12),                               # Γραμματοσειρά και μέγεθος
            text_color=self.theme.get("error_text", "#ff4444")# Χρώμα κειμένου (κόκκινο για σφάλματα)
        )
        self.tooltip_label.grid(
            row=6, column=0, columnspan=4,                    # Τοποθέτηση στη γραμμή 6, στήλες 0-3
            pady=(0, 2)                                       # Κάθετο περιθώριο (πάνω 0, κάτω 2)
        )

        #==================== ΚΟΥΜΠΙ ΜΕΤΑΤΡΟΠΗΣ ====================
        # Κουμπί για εκκίνηση της μετατροπής αριθμού
        self.convert_button = ctk.CTkButton(
            self,                                         # Το τρέχον frame ως γονέας
            text="CONVERT",                               # Κείμενο κουμπιού
            font=("Arial", 16, "bold"),                   # Γραμματοσειρά και μέγεθος
            height=50,                                    # Ύψος κουμπιού
            command=self.convert_number,                   # Συνάρτηση που καλείται όταν πατηθεί το κουμπί
            fg_color=theme.get("special_button_fg", "#eb7c16"),    # Χρώμα φόντου κουμπιού
            text_color=theme.get("op_button_text", "#ffffff"),      # Χρώμα κειμένου κουμπιού
            hover_color=theme.get("op_hover", "#5e5e5e")            # Χρώμα όταν το ποντίκι είναι πάνω στο κουμπί
        )
        self.convert_button.grid(
            row=7, column=1, columnspan=3,                # Τοποθέτηση στη γραμμή 7, στήλες 1-3
            padx=10, pady=(0, 20),                        # Περιθώρια γύρω από το κουμπί
            sticky="ew"                                   # Επέκταση οριζόντια
        )

        #==================== ΑΠΟΤΕΛΕΣΜΑ ====================
        # Ετικέτα για το αποτέλεσμα της μετατροπής
        self.result_label = ctk.CTkLabel(
            self,                                         # Το τρέχον frame ως γονέας
            text="RESULT",                                # Κείμενο ετικέτας
            font=("Arial", 14, "bold"),                   # Γραμματοσειρά και μέγεθος
            text_color=theme.get("label_text", "#ffffff") # Χρώμα κειμένου ετικέτας
        )
        self.result_label.grid(
            row=8, column=1, columnspan=3,                # Τοποθέτηση στη γραμμή 8, στήλες 1-3
            pady=(20, 2),                                 # Κάθετα περιθώρια
            sticky="s"                                    # Στοίχιση στο κάτω μέρος του κελιού
        )

        # Πεδίο εισαγωγής για την εμφάνιση του αποτελέσματος της μετατροπής
        self.result_entry = ctk.CTkEntry(
            self,                                         # Το τρέχον frame ως γονέας
            font=("Arial", 18, "bold"),                   # Γραμματοσειρά και μέγεθος
            height=40,                                    # Ύψος πεδίου
            text_color=theme.get("display_text", "#00ff00"),   # Χρώμα κειμένου αποτελέσματος
            fg_color=theme.get("display_bg", "#000000"),       # Χρώμα φόντου πεδίου
            justify="center"                              # Στοίχιση κειμένου στο κέντρο
        )
        self.result_entry.grid(
            row=9, column=1, columnspan=3,                # Τοποθέτηση στη γραμμή 9, στήλες 1-3
            padx=10, pady=(2, 0),                         # Περιθώρια γύρω από το πεδίο
            sticky="ewn"                                  # Επέκταση οριζόντια και στο βόρειο άκρο
        )

        #==================== ΚΟΥΜΠΙ ΑΝΤΙΓΡΑΦΗΣ ====================
        # Κουμπί για αντιγραφή του αποτελέσματος στο πρόχειρο
        self.copy_button = ctk.CTkButton(
            self,                                         # Το τρέχον frame ως γονέας
            text="📋",                                    # Εικονίδιο κουμπιού (clipboard)
            width=1,                                      # Πλάτος κουμπιού
            height=40,                                    # Ύψος κουμπιού
            font=("Arial", 16),                           # Γραμματοσειρά και μέγεθος
            fg_color=self.theme.get("special_button_fg", "#eb7c16"),  # Χρώμα φόντου κουμπιού
            border_width=2,                               # Πάχος περιγράμματος
            border_color=theme.get("border_color", "#000000"),         # Χρώμα περιγράμματος
            hover_color="#000000",                        # Χρώμα όταν το ποντίκι είναι πάνω στο κουμπί
            text_color=self.theme.get("special_button_text", "#ffffff"), # Χρώμα κειμένου
            command=self.copy_result                      # Συνάρτηση που καλείται όταν πατηθεί το κουμπί
        )
        # Τοποθέτηση του κουμπιού αντιγραφής στη γραμμή 9, στήλη 4, με κάθετο περιθώριο (2, 0) και στοίχιση αριστερά-πάνω ("wn")
        self.copy_button.grid(row=9, column=4, pady=(2, 0), sticky="wn")

        # Ετικέτα για εμφάνιση μηνύματος επιτυχίας αντιγραφής (π.χ. "✔ Copied!")
        self.copy_tooltip_label = ctk.CTkLabel(
            self,                                   # Το τρέχον frame ως γονέας
            text="",                                # Αρχικά κενό κείμενο
            font=("Arial", 11, "italic"),           # Γραμματοσειρά και μέγεθος
            text_color="#33ff33"                    # Χρώμα κειμένου (πράσινο)
        )
        # Τοποθέτηση της ετικέτας στη γραμμή 10, στήλες 2-3, με κάθετο περιθώριο (0, 60), οριζόντιο περιθώριο 15 και στοίχιση δεξιά-πάνω ("en")
        self.copy_tooltip_label.grid(row=10, column=2, columnspan=2, pady=(0, 60), padx=15, sticky="en")

    #==================== ΕΝΗΜΕΡΩΣΗ ΕΠΙΤΡΕΠΤΩΝ ΨΗΦΙΩΝ ====================
    def update_allowed_digits_label(self):  # Ενημέρωση της ετικέτας με τα επιτρεπτά ψηφία για τη βάση "from"
        base = int(self.from_base_menu.get())  # Παίρνει τη βάση από το μενού επιλογής "from"
        digits = "0123456789ABCDEF"[:base]     # Επιλέγει τα επιτρεπτά ψηφία για τη βάση
        self.allowed_digits_label.configure(   # Ενημερώνει την ετικέτα με τα επιτρεπτά ψηφία
            text=f"Allowed characters: {digits}"
        )
        """
        Αυτή η μέθοδος είναι υπεύθυνη για την ενημέρωση του κειμένου μιας ετικέτας (self.allowed_digits_label) 
        που δείχνει ποιοι χαρακτήρες είναι έγκυροι για την τρέχουσα επιλεγμένη βάση εισόδου. 
        1.	base = int(self.from_base_menu.get()): Λαμβάνει την επιλεγμένη τιμή από το αναπτυσσόμενο μενού 
        (self.from_base_menu) και τη μετατρέπει σε ακέραιο.
        2.	digits = "0123456789ABCDEF"[:base]: Δημιουργεί ένα string digits που περιέχει τους επιτρεπτούς χαρακτήρες 
        για τη συγκεκριμένη base. 
        Χρησιμοποιείται string slicing: για παράδειγμα, αν base είναι 2, το digits θα είναι "01". 
        Αν base είναι 16, το digits θα είναι "0123456789ABCDEF".
        3.	self.allowed_digits_label.configure(text=f"Allowed characters: {digits}"): 
        Ενημερώνει την ιδιότητα text της ετικέτας με το μορφοποιημένο string.
        """


    # ==================== ΑΝΤΑΛΛΑΓΗ ΒΑΣΕΩΝ ====================
    def swap_bases(self):  # Ανταλλαγή βάσεων
        """
        Αυτή η μέθοδος ανταλλάσσει τις επιλεγμένες βάσεις εισόδου και εξόδου στα dropdown menus.
        Επίσης, μετά την ανταλλαγή, επικυρώνει την τρέχουσα τιμή του πεδίου εισόδου
        έναντι της *νέας* βάσης εισόδου (που ήταν η προηγούμενη βάση εξόδου)
        και ενημερώνει αναλόγως την οθόνη του χρήστη.
        """

        """
           Παίρνουμε τις τρέχουσες επιλεγμένες βάσεις ΠΡΙΝ γίνει οποιαδήποτε αλλαγή στα menus.
           Οι τιμές των 'from_base' και 'to_base' αυτή τη στιγμή αναφέρονται στις
           επιλογές των menus πριν από την ανταλλαγή τους.
        """
        from_base = self.from_base_menu.get()  # Παίρνει την τρέχουσα βάση "from"
        to_base = self.to_base_menu.get()  # Παίρνει την τρέχουσα βάση "to"

        """
           Πραγματοποιούμε την ανταλλαγή των βάσεων στα CTkComboBox widgets.
           Μετά αυτές τις γραμμές, οι επιλογές των menus έχουν αλλάξει:
           Η 'from_base_menu' δείχνει τώρα την αρχική τιμή του 'to_base' (που είναι η *νέα* FROM BASE).
           Η 'to_base_menu' δείχνει τώρα την αρχική τιμή του 'from_base' (που είναι η *νέα* TO BASE).
           Σημείωση: Οι τοπικές μεταβλητές 'from_base' και 'to_base' σε αυτό το σημείο
           εξακολουθούν να κρατούν τις *αρχικές* τιμές τους πριν από το set().
        """
        self.from_base_menu.set(to_base)  # Ορίζει τη βάση "from" στη βάση "to"
        self.to_base_menu.set(from_base)  # Ορίζει τη βάση "to" στη βάση "from"

        """
           Ενημερώνουμε την ετικέτα των επιτρεπτών ψηφίων.
           Αυτή η μέθοδος (update_allowed_digits_label) χρησιμοποιεί το self.from_base_menu.get(),
           το οποίο πλέον επιστρέφει την *πραγματική νέα* βάση εισόδου (δηλαδή την αρχική τιμή του 'to_base').
        """
        self.update_allowed_digits_label()  # Ενημερώνει την ετικέτα επιτρεπτών ψηφίων

        """
           Παίρνουμε την τρέχουσα τιμή από το πεδίο εισόδου (input_entry).
           Αυτή είναι η τιμή που ο χρήστης είχε εισάγει πριν πατήσει το κουμπί swap.
           Αφαιρεί τυχόν κενά στην αρχή/τέλος (strip()) και αντικαθιστά τυχόν κόμματα με τελείες (replace(",", ".")) 
           για να διευκολύνει την επεξεργασία δεκαδικών αριθμών ανεξάρτητα από την τοπική ρύθμιση του χρήστη.
        """
        value = self.input_entry.get().strip().replace(",", ".")  # Παίρνει την τιμή από το πεδίο εισόδου και αντικαθιστά το κόμμα με τελεία


        """
        Καθορισμός των επιτρεπτών ψηφίων για την επικύρωση της εισόδου.
        Ορίζουμε τη μεταβλητή 'allowed_digits' ως ένα υποσύνολο του 'REVERSE_MAP'.
        
           REVERSE_MAP: Είναι μια σταθερή συμβολοσειρά που περιέχει όλα τα πιθανά ψηφία
           για βάσεις έως το 16 (0-9 και A-F). Λειτουργεί ως ο "πίνακας αναφοράς" μας.
           Κάθε χαρακτήρας βρίσκεται σε μια θέση (index) που αντιστοιχεί στην αριθμητική του αξία.
           (π.χ., το '0' είναι στο index 0, το '9' στο index 9, το 'A' στο index 10, κ.ο.κ.)

           int(to_base): Σε αυτό το σημείο της μεθόδου 'swap_bases', η τοπική μεταβλητή 'to_base'
           περιέχει την αρχική τιμή της βάσης εξόδου (πριν το swap), η οποία όμως μετά την ανταλλαγή
           έχει οριστεί ως η *νέα βάση εισόδου* (FROM BASE) για την εφαρμογή.
           Έτσι, το 'int(to_base)' μας δίνει την ακέραια τιμή της *νέας βάσης εισόδου*.

           REVERSE_MAP[:int(to_base)]: Χρησιμοποιούμε τη λειτουργία "slicing" (τεμαχισμού)
           της Python σε strings. Αυτή η σύνταξη παίρνει όλους τους χαρακτήρες από την αρχή
           του 'REVERSE_MAP' (θέση 0) μέχρι τη θέση που υποδεικνύει το 'int(to_base)',
           εξαιρουμένου του χαρακτήρα στη θέση 'int(to_base)'.
           
           Παραδείγματα:
           - Αν η νέα βάση εισόδου (int(to_base)) είναι 2 (δυαδικό):
             allowed_digits = REVERSE_MAP[:2]  -> "01" (μόνο τα ψηφία 0 και 1)
           - Αν η νέα βάση εισόδου (int(to_base)) είναι 10 (δεκαδικό):
             allowed_digits = REVERSE_MAP[:10] -> "0123456789" (όλα τα δεκαδικά ψηφία)
           - Αν η νέα βάση εισόδου (int(to_base)) είναι 16 (δεκαεξαδικό):
             allowed_digits = REVERSE_MAP[:16] -> "0123456789ABCDEF" (όλα τα δεκαεξαδικά ψηφία)

        Αυτή η προσέγγιση εξασφαλίζει ότι η μεταβλητή 'allowed_digits' περιέχει δυναμικά
        ακριβώς τους χαρακτήρες-ψηφία που είναι έγκυροι για την *νέα επιλεγμένη βάση εισόδου*."""
        REVERSE_MAP = "0123456789ABCDEF"  # Χάρτης επιτρεπτών ψηφίων για βάσεις έως 16
        allowed_digits = REVERSE_MAP[:int(to_base)]  # Επιτρεπτά ψηφία για τη βάση εξόδου

        """
          Καθαρίζουμε τυχόν προηγούμενα μηνύματα σφάλματος/βοήθειας και το αποτέλεσμα.
        """
        self.tooltip_label.configure(text="")  # Καθαρίζει το μήνυμα βοήθειας/σφάλματος
        self.result_entry.delete(0, tk.END)  # Καθαρίζει το πεδίο αποτελέσματος

        """
        Διαχωρίζουμε τον αριθμό σε ακέραιο και δεκαδικό μέρος για τον έλεγχο ψηφίων.
        Συνενώνουμε τα μέρη για συνολικό έλεγχο (full_value).
        """
        if "." in value:  # Έλεγχος αν υπάρχει δεκαδικό μέρος
            int_part, frac_part = value.split(".")  # Διαχωρισμός σε ακέραιο και δεκαδικό μέρος
        else:
            int_part, frac_part = value, ""  # Αν δεν υπάρχει δεκαδικό μέρος

        full_value = int_part + frac_part  # Συνένωση όλων των ψηφίων για έλεγχο εγκυρότητας

        """
        Εκτελούμε τον έλεγχο εγκυρότητας των ψηφίων.
        Αν κάποιο ψηφίο δεν είναι έγκυρο για τη νέα βάση εισόδου:
          - Εμφανίζεται μήνυμα σφάλματος (tooltip_label).
          - Το περίγραμμα του πεδίου εισόδου (input_entry) γίνεται κόκκινο για οπτική ένδειξη.
          - Επαναφέρεται το χρώμα του περιγράμματος μετά από 2 δευτερόλεπτα.
          - Η εκτέλεση της συνάρτησης σταματάει (return), καθώς η είσοδος είναι άκυρη για τη νέα βάση.
        """
        if not all(char.upper() in allowed_digits for char in
                   full_value):  # Έλεγχος αν όλα τα ψηφία είναι επιτρεπτά για τη βάση εξόδου
            self.tooltip_label.configure(
                text=f"Input '{value}' not valid in base {to_base} → please re-enter.")  # Εμφανίζει μήνυμα σφάλματος
            self.input_entry.configure(border_color="#ff4444")  # Κάνει κόκκινο το περίγραμμα του πεδίου εισόδου
            self.after(2000, lambda: self.input_entry.configure(border_color=self.theme.get("border_color",
                                                                                            "#000000")))  # Επαναφέρει το περίγραμμα μετά από 2 δευτερόλεπτα

            """
        Αν η είσοδος είναι έγκυρη για τη νέα βάση εισόδου, τότε καλούμε τη μέθοδο μετατροπής.
        Αυτή θα υπολογίσει το νέο αποτέλεσμα και θα το εμφανίσει.
        Εξασφαλίζουμε ότι το περίγραμμα του πεδίου εισόδου είναι στο κανονικό του χρώμα.
        """
        else:
            self.input_entry.configure(border_color=self.theme.get("border_color",
                                                                   "#000000"))  # Επαναφέρει το χρώμα περιγράμματος αν η είσοδος είναι έγκυρη



    # ==================== ΜΕΤΑΤΡΟΠΗ ΑΡΙΘΜΟΥ ====================
    def convert_number(self):  # Συνάρτηση μετατροπής αριθμού μεταξύ βάσεων
        """Αυτή η μέθοδος περιλαμβάνει την πλήρη διαδικασία μετατροπής αριθμών μεταξύ διαφορετικών βάσεων,
        χειρισμό ακέραιων και δεκαδικών μερών, καθώς και ανίχνευση περιοδικών δεκαδικών. """

        """
        1. Αρχική Προετοιμασία:
           - Λαμβάνουμε την τιμή εισόδου από το 'input_entry', αφαιρούμε κενά και αντικαθιστούμε κόμμα με τελεία
             για να διασφαλίσουμε τη σωστή μορφοποίηση δεκαδικών αριθμών (π.χ., "3,14" γίνεται "3.14").
           - Παίρνουμε τις επιλεγμένες βάσεις εισόδου ('from_base') και εξόδου ('to_base') από τα dropdown menus
             και τις μετατρέπουμε σε ακέραιους αριθμούς.
        """
        value = self.input_entry.get().strip().replace(",", ".")  # Παίρνει την τιμή εισόδου και αντικαθιστά το κόμμα με τελεία
        from_base = int(self.from_base_menu.get())  # Παίρνει τη βάση εισόδου από το μενού
        to_base = int(self.to_base_menu.get())  # Παίρνει τη βάση εξόδου από το μενού

        try:
            """
            2. Ορισμός Χαρτών Ψηφίων:
               - DIGIT_MAP: Ένα λεξικό που αντιστοιχίζει κάθε χαρακτήρα ψηφίου (0-9, A-F, a-f)
                 στην αντίστοιχη ακέραια αριθμητική του τιμή. Χρησιμοποιείται για τη μετατροπή
                 ψηφίων της εισόδου σε αριθμητικές τιμές.
               - REVERSE_MAP: Μια συμβολοσειρά που περιέχει τους χαρακτήρες ψηφίων με σειρά (0-9, A-F).
                 Ο δείκτης (index) κάθε χαρακτήρα αντιστοιχεί στην αριθμητική του τιμή.
                 Χρησιμοποιείται για τη μετατροπή ακέραιων τιμών σε χαρακτήρες ψηφίων κατά την έξοδο.
            """
            DIGIT_MAP = {  # Χάρτης για μετατροπή ψηφίων σε ακέραιους
                '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
                '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
                'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,
                'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15
            }

            REVERSE_MAP = "0123456789ABCDEF"  # Χάρτης για μετατροπή ακέραιων σε ψηφία

            # --- Ανάλυση εισόδου σε ακέραιο και δεκαδικό μέρος ---
            """
            3. Ανάλυση Εισόδου και Έλεγχος Εγκυρότητας:
               - Διαχωρίζουμε την είσοδο σε ακέραιο ('int_part') και δεκαδικό ('frac_part') μέρος.
                 Αν δεν υπάρχει τελεία, το δεκαδικό μέρος είναι κενό.
               - Υπολογίζουμε τα επιτρεπτά ψηφία ('allowed_digits') για την τρέχουσα 'from_base'
                 χρησιμοποιώντας το 'REVERSE_MAP' και slicing (π.χ., για βάση 2, παίρνουμε "01").
               - Συγκεντρώνουμε όλα τα ψηφία της εισόδου (ακέραια και δεκαδικά) στο 'full_value'.
               - Ελέγχουμε με τη συνάρτηση 'all()' αν ΚΑΘΕ ψηφίο του 'full_value' (που έχει ηδη μετατραπεί σε κεφαλαίο)
                 περιλαμβάνεται στα 'allowed_digits'. Αν βρεθεί έστω και ένα μη επιτρεπτό ψηφίο,
                 δημιουργείται 'ValueError' και η εκτέλεση πηγαίνει στο 'except' block.
            """
            if "." in value:
                int_part, frac_part = value.split(".")  # Διαχωρισμός σε ακέραιο και δεκαδικό μέρος
            else:
                int_part, frac_part = value, ""  # Αν δεν υπάρχει δεκαδικό μέρος

            # --- Έλεγχος επιτρεπτών ψηφίων για τη βάση εισόδου ---
            allowed_digits = REVERSE_MAP[:from_base]  # Επιτρεπτά ψηφία για τη βάση
            full_value = int_part + frac_part  # Όλα τα ψηφία της εισόδου
            if not all(char.upper() in allowed_digits for char in full_value):
                raise ValueError  # Εξαίρεση αν βρεθεί μη επιτρεπτό ψηφίο
            """Επαναλαμβάνεται ο έλεγχος με το all() για να διασφαλιστεί ότι όλα τα ψηφία της εισόδου 
            είναι έγκυρα για την from_base. Αν όχι, δημιουργείται ValueError."""

            # --- Μετατροπή ακέραιου μέρους σε δεκαδικό ---
            """
            4. Μετατροπή Ακέραιου Μέρους από 'from_base' σε Δεκαδικό (Βάση 10):
               - Το 'decimal_int' θα κρατήσει την δεκαδική (βάση 10) αναπαράσταση του ακέραιου μέρους.
               - Επαναλαμβάνουμε τα ψηφία του 'int_part' με αντίστροφη σειρά ('reversed'),
                 ώστε το πρώτο ψηφίο που επεξεργαζόμαστε να είναι το πιο δεξιό (μικρότερης δύναμης).
                 Το 'enumerate' μας δίνει και τον δείκτη 'i', που αντιστοιχεί στη δύναμη της 'from_base'.
               - Κάθε ψηφίο μετατρέπεται στην αριθμητική του τιμή μέσω του 'DIGIT_MAP' και πολλαπλασιάζεται
                 με τη δύναμη της 'from_base' στην αντίστοιχη θέση (from_base ** i).
                 Τα αποτελέσματα προστίθενται στο 'decimal_int'.
            """
            decimal_int = 0
            for i, digit in enumerate(reversed(int_part.upper())):
                """Το reversed() παίρνει τα ψηφία από δεξιά προς αριστερά, 
                και το enumerate δίνει τον δείκτη i (δύναμη της βάσης)."""
                decimal_int += DIGIT_MAP[digit] * (from_base ** i)  # Υπολογισμός τιμής κάθε ψηφίου

            # --- Μετατροπή δεκαδικού μέρους σε δεκαδικό (Fraction για ακρίβεια) ---
            """
            5. Μετατροπή Δεκαδικού Μέρους από 'from_base' σε Δεκαδικό (Βάση 10) ως Κλάσμα:
               - Χρησιμοποιούμε τη βιβλιοθήκη 'fractions.Fraction' για να διατηρήσουμε την ακρίβεια
                 και να αποφύγουμε σφάλματα στρογγυλοποίησης με float.
               - Το 'decimal_frac' αρχικοποιείται ως κλάσμα 0/1.
               - Επαναλαμβάνουμε τα ψηφία του 'frac_part' ξεκινώντας από τον δείκτη 1 (για το 1ο δεκαδικό ψηφίο).
               - Κάθε δεκαδικό ψηφίο μετατρέπεται σε κλάσμα: (αριθμητική τιμή ψηφίου) / (from_base ** i),
                 όπου 'i' είναι η θέση του ψηφίου μετά την υποδιαστολή (1, 2, 3...).
               - Τα κλάσματα αυτά προστίθενται στο 'decimal_frac'.
               - Τέλος, προσθέτουμε το 'decimal_int' (ως κλάσμα) στο 'decimal_frac' για να πάρουμε τη 'total'
                 δεκαδική τιμή του αριθμού ως ένα ενιαίο, ακριβές κλάσμα.
            """
            decimal_frac = Fraction(0, 1)  # Αρχικοποίηση δεκαδικού μέρους ως Fraction
            for i, digit in enumerate(frac_part.upper(), start=1):  # Ξεκινάμε από 1 για το δεκαδικό μέρος
                decimal_frac += Fraction(DIGIT_MAP[digit], from_base ** i)  # Πρόσθεση κάθε δεκαδικού ψηφίου
                """Κάθε δεκαδικό ψηφίο μετατρέπεται σε κλάσμα (digit/basei) και προστίθεται στο decimal_frac."""

            total = Fraction(decimal_int) + decimal_frac  # Συνολική δεκαδική τιμή
            """Συνενώνει τα δύο μέρη σε ένα ενιαίο κλάσμα, διατηρώντας την ακρίβεια."""

            # --- Αν η βάση εξόδου είναι 10, εμφάνιση ως float ---
            """
            6. Διαχείριση Βάσης Εξόδου 10:
               - Αν η 'to_base' είναι 10, ο αριθμός είναι ήδη σε δεκαδική μορφή (στο 'total' ως κλάσμα).
               - Μετατρέπουμε το 'total' σε 'float'.
               - Χρησιμοποιούμε μορφοποίηση string ('f"{result:.15f}"') για να εξασφαλίσουμε ακρίβεια έως 15 δεκαδικά
                 και στη συνέχεια αφαιρούμε τυχόν περιττά μηδενικά στο τέλος και την τελεία αν δεν υπάρχουν δεκαδικά.
            """
            if to_base == 10:  # Αν η βάση εξόδου είναι 10
                result = float(total)  # Μετατροπή σε float
                result = f"{result:.15f}".rstrip('0').rstrip('.')  # Μορφοποίηση χωρίς περιττά μηδενικά
                """Αν η to_base είναι 10, το κλάσμα μετατρέπεται σε float 
                και μορφοποιείται για να αφαιρεθούν τα περιττά μηδενικά"""
            else:
                # --- Μετατροπή ακέραιου μέρους στη νέα βάση ---
                """
                7. Μετατροπή Ακέραιου Μέρους στη Νέα Βάση ('to_base'):
                   - Το 'int_val' είναι το ακέραιο μέρος του 'total' (αριθμητής // παρονομαστής).
                   - Χρησιμοποιείται ο κλασικός αλγόριθμος διαίρεσης με υπόλοιπο:
                     - Ενώ το 'int_val' είναι μεγαλύτερο από 0:
                       - Υπολογίζεται το υπόλοιπο της διαίρεσης του 'int_val' με τη 'to_base'. Αυτό είναι το επόμενο ψηφίο.
                       - Το ψηφίο μετατρέπεται σε χαρακτήρα χρησιμοποιώντας το 'REVERSE_MAP' και προστίθεται στη λίστα 'digits'.
                       - Το 'int_val' ενημερώνεται με το ακέραιο πηλίκο της διαίρεσης.
                     - Τα ψηφία συλλέγονται αντίστροφα, οπότε στο τέλος αντιστρέφονται ('reversed')
                       και ενώνονται ('join') για να σχηματίσουν το τελικό ακέραιο μέρος ('int_conv').
                       Αν δεν υπάρχουν ψηφία (π.χ., ο αρχικός αριθμός ήταν 0), ορίζεται ως "0".
                """
                int_val = total.numerator // total.denominator  # Ακέραιο μέρος
                digits = []
                while int_val > 0:
                    digits.append(REVERSE_MAP[int_val % to_base])  # Υπολογισμός ψηφίων στη νέα βάση
                    int_val //= to_base
                int_conv = ''.join(reversed(digits)) if digits else "0"  # Τελικό ακέραιο μέρος στη νέα βάση
                """Χρησιμοποιείται ο αλγόριθμος της διαίρεσης με υπόλοιπο: διαιρείται ο αριθμός με τη νέα βάση, 
                το υπόλοιπο είναι το επόμενο ψηφίο, και το πηλίκο χρησιμοποιείται για την επόμενη επανάληψη. 
                Τα ψηφία συλλέγονται αντίστροφα."""

                # --- Μετατροπή δεκαδικού μέρους σε επιθυμητή βάση με ανίχνευση περιοδικότητας ---
                """
                8. Μετατροπή Δεκαδικού Μέρους στη Νέα Βάση με Ανίχνευση Περιοδικότητας:
                   - Το 'frac' είναι το δεκαδικό μέρος του 'total' (total - int(total)).
                   - 'digits': Λίστα για τα ψηφία του δεκαδικού μέρους στη νέα βάση.
                   - 'seen': Λεξικό για την ανίχνευση επαναλαμβανόμενων μοτίβων (περιοδικότητα).
                     Το κλειδί είναι ένα ζεύγος (αριθμητής, παρονομαστής) του κλάσματος σε κάθε βήμα.
                     Η τιμή είναι ο δείκτης (θέση) όπου εμφανίστηκε το συγκεκριμένο ζεύγος.
                   - 'periodic_index': Θα κρατήσει τον δείκτη έναρξης του περιοδικού μέρους αν βρεθεί.
                   - Η επανάληψη (βρόχος 'for i in range(100)') εκτελείται για ένα μέγιστο αριθμό ψηφίων (100)
                     για να αποφευχθεί ένας άπειρος βρόχος σε περίπτωση μη-τερματίζουσας/μη-περιοδικής μετατροπής
                     (αν και για ρητούς αριθμούς είναι πάντα τερματίζουσα ή περιοδική).
                   - Εάν ο αριθμητής γίνει 0, το δεκαδικό μέρος έχει τερματίσει.
                   - Εάν το ζεύγος (numerator, denominator) εμφανιστεί ξανά στο 'seen', βρέθηκε περιοδικότητα.
                     Αποθηκεύεται ο 'periodic_index' και ο βρόχος σταματάει.
                   - Σε κάθε βήμα, ο 'numerator' πολλαπλασιάζεται με την 'to_base'.
                   - Το ακέραιο μέρος του αποτελέσματος ('digit = numerator // denominator') είναι το επόμενο δεκαδικό ψηφίο.
                   - Το ψηφίο προστίθεται στο 'digits'.
                   - Το υπόλοιπο ('numerator %= denominator') γίνεται ο νέος αριθμητής για την επόμενη επανάληψη.
                """
                frac = total - int(total)  # Υπολογισμός δεκαδικού μέρους
                """Απομονώνει το δεκαδικό μέρος του συνολικού κλάσματος."""
                frac = Fraction(frac)  # Μετατροπή σε Fraction για ακριβή υπολογισμό

                digits = []  # Λίστα για τα ψηφία του δεκαδικού μέρους στη νέα βάση
                seen = {}  # Λεξικό για ανίχνευση περιοδικών κλασμάτων
                """seen = {}: Ένα λεξικό που χρησιμοποιείται για την ανίχνευση περιοδικών επαναλήψεων. 
                Το "κλειδί" είναι ένα ζεύγος (numerator, denominator) του κλάσματος σε κάθε βήμα. 
                Αν ένα κλειδί εμφανιστεί ξανά, σημαίνει ότι έχει βρεθεί ένα επαναλαμβανόμενο μοτίβο."""
                periodic_index = None  # Δείκτης έναρξης περιοδικού μέρους (αν υπάρχει)

                numerator = frac.numerator  # Αριθμητής του δεκαδικού μέρους
                denominator = frac.denominator  # Παρονομαστής του δεκαδικού μέρους

                # Επανάληψη για μετατροπή δεκαδικού μέρους (μέχρι 100 ψηφία ή αν βρεθεί περιοδικότητα)
                """ 1.	Πολλαπλασιασμός του αριθμητή του δεκαδικού μέρους με τη to_base.
                    2.	Το ακέραιο μέρος του αποτελέσματος είναι το επόμενο ψηφίο.
                    3.	Το υπόλοιπο (modulo) γίνεται ο νέος αριθμητής.
                    4.	Επανάληψη.
                    5.	range(100): Ένα όριο για τον αριθμό των ψηφίων ώστε να αποφευχθεί ένας άπειρος βρόχος 
                    σε μη-τερματίζουσες/μη-περιοδικές μετατροπές 
                    (αν και για ρητούς αριθμούς είναι πάντα τερματίζουσα ή περιοδική).
                """
                for i in range(100):  # Μέγιστο 100 ψηφία για αποφυγή ατέρμονων επαναλήψεων
                    if numerator == 0:  # Αν ο αριθμητής γίνει 0, σταματάμε
                        break  # Τέλος αν το δεκαδικό μέρος μηδενιστεί
                    key = (numerator, denominator)  # Δημιουργία κλειδιού για ανίχνευση περιοδικότητας
                    if key in seen:  # Έλεγχος αν το κλειδί έχει ήδη εμφανιστεί
                        periodic_index = seen[key]  # Βρέθηκε περιοδικότητα
                        break
                    seen[key] = i  # Αποθήκευση της θέσης του κλειδιού

                    numerator *= to_base  # Πολλαπλασιασμός του αριθμητή με τη βάση εξόδου
                    digit = numerator // denominator  # Υπολογισμός ψηφίου στη νέα βάση
                    digits.append(REVERSE_MAP[digit])  # Προσθήκη ψηφίου στη λίστα
                    numerator %= denominator


                # --- Διαχωρισμός περιοδικού και μη περιοδικού μέρους ---
                """
                9. Μορφοποίηση Δεκαδικού Μέρους (Περιοδικότητα):
                   - Αν το 'periodic_index' δεν είναι 'None' (δηλαδή βρέθηκε περιοδικότητα):
                     - Διαχωρίζουμε τα 'digits' σε μη-περιοδικό και περιοδικό μέρος.
                     - Μορφοποιούμε το 'frac_conv' με παρενθέσεις γύρω από το περιοδικό μέρος
                       (π.χ., "0.12(34)").
                   - Αν δεν υπάρχει περιοδικότητα:
                     - Ενώνουμε όλα τα δεκαδικά ψηφία και αφαιρούμε τυχόν περιττά μηδενικά στο τέλος.
                """
                if periodic_index is not None:  # Αν βρέθηκε περιοδικό μέρος
                    non_periodic = ''.join(digits[:periodic_index])  # Μη περιοδικό μέρος
                    periodic = ''.join(digits[periodic_index:])  # Περιοδικό μέρος
                    frac_conv = f"{non_periodic}({periodic})"  # Παρουσίαση με παρένθεση
                else:
                    frac_conv = ''.join(digits).rstrip('0')  # Χωρίς περιοδικότητα, αφαίρεση τελικών μηδενικών

                # --- Τελικό αποτέλεσμα ---
                """
                10. Τελικό Αποτέλεσμα:
                    - Συνενώνουμε το ακέραιο ('int_conv') και το δεκαδικό ('frac_conv') μέρος
                      με μια τελεία ενδιάμεσα.
                    - Αν δεν υπάρχει δεκαδικό μέρος ('frac_conv' είναι κενό), το αποτέλεσμα είναι μόνο το ακέραιο μέρος.
                """
                result = f"{int_conv}.{frac_conv}" if frac_conv else int_conv  # Συνένωση ακέραιου και δεκαδικού μέρους

            # --- Ενημέρωση GUI με το αποτέλεσμα ---
            """
            11. Ενημέρωση GUI με το Αποτέλεσμα και Καθαρισμός/Επαναφορά UI:
                - Καθαρίζουμε το πεδίο αποτελέσματος ('result_entry').
                - Εισάγουμε το υπολογισμένο 'result' στο 'result_entry'.
                - Καθαρίζουμε τυχόν μηνύματα σφάλματος/βοήθειας από το 'tooltip_label'.
                - Επαναφέρουμε το χρώμα περιγράμματος του πεδίου εισόδου ('input_entry')
                  στο προεπιλεγμένο χρώμα του θέματος.
            """
            self.result_entry.delete(0, tk.END)  # Καθαρίζει το πεδίο αποτελέσματος
            self.result_entry.insert(0, str(result))  # Εισάγει το αποτέλεσμα στο πεδίο αποτελέσματος
            self.tooltip_label.configure(text="")  # Καθαρίζει το μήνυμα βοήθειας/σφάλματος
            self.input_entry.configure(  # Επαναφέρει το χρώμα περιγράμματος της εισόδου
                border_color=self.theme.get("border_color", "#000000")
            )

        except:
            """
            12. Χειρισμός Σφαλμάτων (Error Handling):
                - Αυτό το 'except' block εκτελείται αν προκύψει οποιοδήποτε σφάλμα ('ValueError' ή άλλο)
                  κατά τη διάρκεια της εκτέλεσης του 'try' block.
                - Υπολογίζεται το 'last': το μέγιστο επιτρεπτό ψηφίο για την 'from_base' (π.χ., για βάση 10, είναι το '9';
                  για βάση 16, είναι το 'F').
                - Εμφανίζεται ένα μήνυμα σφάλματος στο 'tooltip_label' που ενημερώνει τον χρήστη
                  για τα αποδεκτά ψηφία.
                - Καθαρίζεται το πεδίο αποτελέσματος.
                - Το περίγραμμα του πεδίου εισόδου γίνεται κόκκινο ('#ff4444') για οπτική ένδειξη σφάλματος.
                - Μετά από 2 δευτερόλεπτα (1500ms), ένα 'lambda' function επαναφέρει το χρώμα του περιγράμματος
                  στο προεπιλεγμένο χρώμα του θέματος.
            """
            last = "0123456789ABCDEF"[from_base - 1]  # Βρίσκει το μέγιστο επιτρεπτό ψηφίο για τη βάση
            self.tooltip_label.configure(  # Ενημερώνει την ετικέτα με μήνυμα σφάλματος
                text=f"Accepted digits: 0-{last}"  # Εμφανίζει μήνυμα με τα αποδεκτά ψηφία
            )
            self.result_entry.delete(0, tk.END)  # Καθαρίζει το πεδίο αποτελέσματος
            self.input_entry.configure(
                border_color="#ff4444")  # Κάνει κόκκινο το περίγραμμα της εισόδου για ένδειξη σφάλματος
            self.after(
                2000,
                lambda: self.input_entry.configure(
                    border_color=self.theme.get("border_color", "#000000")
                ),
            )  # Επαναφέρει το περίγραμμα μετά από 2 δευτερόλεπτα


    #==================== ΑΝΤΙΓΡΑΦΗ ΑΠΟΤΕΛΕΣΜΑΤΟΣ ====================
    def copy_result(self):
        result = self.result_entry.get()                         # Παίρνει το αποτέλεσμα από το πεδίο αποτελέσματος
        self.clipboard_clear()                                   # Καθαρίζει το πρόχειρο
        self.clipboard_append(result)                            # Αντιγράφει το αποτέλεσμα στο πρόχειρο
        self.update()                                            # Ενημερώνει το GUI
        self.copy_tooltip_label.configure(text="✔ Copied!")      # Εμφανίζει μήνυμα επιτυχίας αντιγραφής
        self.after(
            1500,
            lambda: self.copy_tooltip_label.configure(text="")
        )                                                        # Κρύβει το μήνυμα μετά από 1.5 δευτερόλεπτο
        """Η μέθοδος copy_result χρησιμοποιεί τις ενσωματωμένες λειτουργίες του tkinter για το clipboard. 
        Εμφανίζει ένα προσωρινό μήνυμα επιτυχίας. """

#==================== ΕΚΚΙΝΗΣΗ ΕΦΑΡΜΟΓΗΣ ====================
if __name__ == "__main__":
    import customtkinter as ctk

    app = ctk.CTk()
    app.geometry("400x600")
    app.title("Number Converter")

    frame = NumberBaseConverter(app, theme=DARK_THEME)
    frame.pack(expand=True, fill="both")

    app.mainloop()
